
//----------------------------------------------------
// The following code was generated by jh-javacup-1.2 20210807
// Fri Jul 01 07:44:22 CST 2022
//----------------------------------------------------

package edu.tsinghua.ss.thufv.specLang.parse;

import com.github.jhoenicke.javacup.runtime.*;
import de.uni_freiburg.informatik.ultimate.ltl2aut.ast.*;
import ast.*;
import java.util.ArrayList;
import java.math.BigInteger;

/** jh-javacup-1.2 20210807 generated parser.
  * @version Fri Jul 01 07:44:22 CST 2022
  */
public class P4LTLParser extends com.github.jhoenicke.javacup.runtime.LRParser {

  /** Default constructor. */
  public P4LTLParser() {super();}

  /** Constructor which sets the default scanner. */
  public P4LTLParser(com.github.jhoenicke.javacup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public P4LTLParser(com.github.jhoenicke.javacup.runtime.Scanner s, com.github.jhoenicke.javacup.runtime.SymbolFactory sf) {super(s,sf);}
  /** The static parse table */
  static com.github.jhoenicke.javacup.runtime.ParseTable CUP$parse_table =
    new com.github.jhoenicke.javacup.runtime.ParseTable(new String[] {
    "\044\000\002\001\003\001\003\001\003\001\003" +
    "\001\003\001\004\001\004\001\004\001\002\001" +
    "\003\001\001\002\004\002\001\003\001\003\003" +
    "\004\003\005\001\053\u0139\u011f\067\u0267\063\061" +
    "\053\u0105\u0271\u024f\235\247\353\321\267\u0237\053" +
    "\235\203\151\117\065\u021f\237\101\055\053\203" +
    "\151\117\u0207\u01ef\u01d7\u01bf\u01a7\u018f\245\247\u0177" +
    "\u015f\u0147\077\053\u0299\000\000\000\000\000\000" +
    "\000\000\000\000\000\000\000\000\000\000\000" +
    "\000\000\000\000\000\000\000\000\000\000\000" +
    "\000\000\000\000\000\000\000\000\000\000\000" +
    "\000\000\000\000\053\001\020\002\006\035\052" +
    "\042\031\036\005\033\004\031\025\003\002\027" +
    "\025\005\025\007\025\011\025\013\051\040\030" +
    "\107\032\113\052\042\031\111\025\015\025\017" +
    "\024\003\035\121\024\005\024\007\024\011\024" +
    "\013\035\043\035\045\035\047\035\051\035\053" +
    "\024\015\024\017\023\003\034\117\023\005\023" +
    "\007\023\011\023\013\034\043\034\045\034\047" +
    "\034\051\034\053\023\015\023\017\022\003\033" +
    "\115\022\005\022\007\022\011\022\013\033\043" +
    "\033\045\033\047\033\051\033\053\022\015\022" +
    "\017\021\003\012\055\021\005\021\007\021\011" +
    "\021\013\012\043\012\045\012\047\012\051\012" +
    "\053\021\015\021\017\016\003\027\044\016\005" +
    "\016\007\016\011\016\013\044\057\013\057\045" +
    "\125\053\001\053\001\016\015\016\017\015\003" +
    "\053\001\015\005\015\007\015\011\015\013\053" +
    "\001\053\001\053\001\053\001\053\001\015\015" +
    "\015\017\014\003\053\001\014\005\014\007\014" +
    "\011\014\013\053\001\053\001\053\001\053\001" +
    "\053\001\014\015\014\017\007\003\053\001\007" +
    "\005\007\007\007\011\007\013\053\001\053\001" +
    "\053\001\053\001\053\001\007\015\007\017\001" +
    "\003\053\001\001\005\001\007\001\011\001\013" +
    "\053\001\053\001\053\001\053\001\053\001\001" +
    "\015\001\017\000\003\053\001\000\005\000\007" +
    "\000\011\000\013\050\022\053\001\050\022\053" +
    "\001\053\001\000\015\000\017\050\022\050\022" +
    "\050\022\050\022\050\022\047\020\053\001\047" +
    "\020\053\001\053\001\053\001\053\001\047\020" +
    "\047\020\047\020\047\020\047\020\046\016\053" +
    "\001\046\016\053\001\053\001\053\001\053\001" +
    "\046\016\046\016\046\016\046\016\046\016\043" +
    "\032\053\001\043\032\053\001\053\001\053\001" +
    "\053\001\043\032\043\032\043\032\043\032\043" +
    "\032\042\010\053\001\042\010\053\001\053\001" +
    "\053\001\053\001\042\043\042\045\042\047\042" +
    "\051\042\053\041\006\053\001\041\006\053\001" +
    "\053\001\053\001\053\001\041\043\041\045\041" +
    "\047\041\006\041\006\040\004\053\001\040\004" +
    "\053\001\053\001\053\001\053\001\040\043\040" +
    "\045\040\004\040\004\040\004\037\014\053\001" +
    "\037\014\053\001\053\001\053\001\053\001\037" +
    "\014\037\014\037\014\037\014\037\014\036\012" +
    "\053\001\036\012\053\001\053\001\053\001\053" +
    "\001\036\012\036\012\036\012\036\012\036\012" +
    "\026\026\053\001\026\026\053\001\053\001\053" +
    "\001\053\001\026\026\026\026\026\026\026\026" +
    "\026\026\017\024\053\001\017\024\053\001\053" +
    "\001\053\001\053\001\017\024\017\024\017\024" +
    "\017\024\017\024\011\030\053\001\011\030\053" +
    "\001\053\001\053\001\053\001\011\030\011\030" +
    "\011\030\011\030\011\030\003\034\053\001\003" +
    "\034\053\001\053\001\010\041\053\001\003\034" +
    "\003\034\003\034\003\034\003\034\010\043\010" +
    "\045\010\047\010\051\010\053\053\001\053\001" +
    "\053\001\053\001\053\001\053\001\053\001\053" +
    "\050\046\001\051\031\032\001\044\030\031\032" +
    "\005\041\037\035\042\011\033\031\027\025\016" +
    "\041\011\040\011\037\011\036\011\035\011\034" +
    "\011\033\011\000\017\011\012\011\010\011"
    });

  /** Return parse table */
  protected com.github.jhoenicke.javacup.runtime.ParseTable parse_table() {
    return CUP$parse_table;
  }

  /** Instance of action encapsulation class. */
  protected CUP$P4LTLParser$action action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$P4LTLParser$action(this);
    }

  /** Invoke a user supplied parse action. */
  public com.github.jhoenicke.javacup.runtime.Symbol do_action(
    int                        act_num,
    java.util.ArrayList        stack)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$do_action(act_num, stack);
  }

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$P4LTLParser$action {
  private final P4LTLParser parser;

  /** Constructor */
  CUP$P4LTLParser$action(P4LTLParser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final com.github.jhoenicke.javacup.runtime.Symbol CUP$do_action(
    int                        CUP$act_num,
    java.util.ArrayList            CUP$stack)
    throws java.lang.Exception
    {
      /* Stack size for peeking into the stack */
      int CUP$size = CUP$stack.size();

      /* select the action based on the action number */
      switch (CUP$act_num)
        {
          // $START ::= texpr EOF 
          case 0:
            {
              Object RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol CUP$rhs$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int CUP$rhsleft = CUP$rhs$.left;
              int CUP$rhsright = CUP$rhs$.right;
              AstNode CUP$rhs = (AstNode) CUP$rhs$.value;
RESULT = CUP$rhs;
/* ACCEPT */
parser.done_parsing();
              return parser.getSymbolFactory().newSymbol("$START", 0, CUP$rhs$, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= texpr AND texpr 
          case 1:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.and, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= texpr OR texpr 
          case 2:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.or, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= texpr IMPLIES texpr 
          case 3:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.implies, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= texpr UNTIL texpr 
          case 4:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.until, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= texpr RELEASE texpr 
          case 5:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.release, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= ALWAYS LPAR texpr RPAR 
          case 6:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = new UnaryTemporalOperator(UnaryTemporalType.always, t); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= EVENTUALLY LPAR texpr RPAR 
          case 7:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = new UnaryTemporalOperator(UnaryTemporalType.eventually, t); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= NEXT LPAR texpr RPAR 
          case 8:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = new UnaryTemporalOperator(UnaryTemporalType.next, t); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= NEG texpr 
          case 9:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = new UnaryTemporalOperator(UnaryTemporalType.neg, t); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2)), t$, RESULT);
            }

          // texpr ::= LPAR texpr RPAR 
          case 10:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = t; 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= predicate 
          case 11:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol p$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int pleft = p$.left;
              int pright = p$.right;
              AstNode p = (AstNode) p$.value;
 RESULT = p; 
              return parser.getSymbolFactory().newSymbol("texpr", 1, p$, p$, RESULT);
            }

          // predicate ::= MATCH LPAR match_args RPAR 
          case 12:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol margs$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int margsleft = margs$.left;
              int margsright = margs$.right;
              AstNode margs = (AstNode) margs$.value;
 RESULT = new Predicate(PredicateType.match, margs); 
              return parser.getSymbolFactory().newSymbol("predicate", 2, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // predicate ::= DROP 
          case 13:
            {
              AstNode RESULT;
 RESULT = new Predicate(PredicateType.drop); 
              com.github.jhoenicke.javacup.runtime.Symbol CUP$sym = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              return parser.getSymbolFactory().newSymbol("predicate", 2, CUP$sym, CUP$sym, RESULT);
            }

          // match_args ::= header_eq 
          case 14:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol he$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int heleft = he$.left;
              int heright = he$.right;
              AstNode he = (AstNode) he$.value;
 RESULT = new Arguments(he); 
              return parser.getSymbolFactory().newSymbol("match_args", 3, he$, he$, RESULT);
            }

          // match_args ::= header_eq COMMA match_args 
          case 15:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol m$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int mleft = m$.left;
              int mright = m$.right;
              AstNode m = (AstNode) m$.value;
              com.github.jhoenicke.javacup.runtime.Symbol he$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int heleft = he$.left;
              int heright = he$.right;
              AstNode he = (AstNode) he$.value;
 RESULT = new Arguments(he, m); 
              return parser.getSymbolFactory().newSymbol("match_args", 3, he$, m$, RESULT);
            }

          // header_eq ::= name EQ INT 
          case 16:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol i$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int ileft = i$.left;
              int iright = i$.right;
              BigInteger i = (BigInteger) i$.value;
              com.github.jhoenicke.javacup.runtime.Symbol n$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int nleft = n$.left;
              int nright = n$.right;
              AstNode n = (AstNode) n$.value;
 RESULT = new ExtendedComparativeOperator(ExtendedComparativeType.eq, n, new BigIntegerLiteral(i)); 
              return parser.getSymbolFactory().newSymbol("header_eq", 4, n$, i$, RESULT);
            }

          // name ::= NAME 
          case 17:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol m$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int mleft = m$.left;
              int mright = m$.right;
              String m = (String) m$.value;
 RESULT = new Name(m); 
              return parser.getSymbolFactory().newSymbol("name", 5, m$, m$, RESULT);
            }

          /* . . . . . .*/
          default:
            throw new InternalError(
               "Invalid action number found in internal parse table");

        }
    }
}

