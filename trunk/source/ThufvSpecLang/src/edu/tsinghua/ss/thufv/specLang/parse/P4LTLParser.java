
//----------------------------------------------------
// The following code was generated by jh-javacup-1.2 20210807
// Mon Jul 11 18:20:06 CST 2022
//----------------------------------------------------

package edu.tsinghua.ss.thufv.specLang.parse;

import com.github.jhoenicke.javacup.runtime.*;
import de.uni_freiburg.informatik.ultimate.ltl2aut.ast.*;
import ast.*;
import java.util.ArrayList;
import java.math.BigInteger;

/** jh-javacup-1.2 20210807 generated parser.
  * @version Mon Jul 11 18:20:06 CST 2022
  */
public class P4LTLParser extends com.github.jhoenicke.javacup.runtime.LRParser {

  /** Default constructor. */
  public P4LTLParser() {super();}

  /** Constructor which sets the default scanner. */
  public P4LTLParser(com.github.jhoenicke.javacup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public P4LTLParser(com.github.jhoenicke.javacup.runtime.Scanner s, com.github.jhoenicke.javacup.runtime.SymbolFactory sf) {super(s,sf);}
  /** The static parse table */
  static com.github.jhoenicke.javacup.runtime.ParseTable CUP$parse_table =
    new com.github.jhoenicke.javacup.runtime.ParseTable(new String[] {
    "\066\000\002\001\003\001\003\001\003\001\003" +
    "\001\003\001\004\001\004\001\004\001\002\001" +
    "\003\001\001\002\004\002\004\002\001\003\001" +
    "\003\003\004\003\004\003\004\003\004\003\006" +
    "\001\006\001\006\003\006\003\006\004\005\001" +
    "\075\u01cb\u01af\113\111\u02cd\105\103\101\u0193\263" +
    "\u02b3\u0123\203\201\u0177\u015b\u013f\u02a9\075\u0123\u0107" +
    "\353\317\263\u028f\075\121\225\201\117\u0107\353" +
    "\317\u0285\u026b\u0261\u0247\u023d\u0223\177\u02c3\u02ab\u0219" +
    "\u01ff\u01f5\u01db\113\075\165\215\155\145\205\135" +
    "\u0163\u0147\u012b\175\125\115\105\u0303\000\000\000" +
    "\000\000\000\000\000\000\000\000\000\000\000" +
    "\000\000\000\000\000\000\000\000\000\000\000" +
    "\000\000\000\000\000\000\000\000\000\000\000" +
    "\000\000\000\000\000\000\000\000\000\000\000" +
    "\000\000\000\000\000\000\000\000\000\000\000" +
    "\000\000\000\075\001\022\002\057\155\031\066" +
    "\007\041\006\037\005\035\074\064\003\033\002" +
    "\031\056\042\073\062\035\125\032\115\075\001" +
    "\072\060\031\066\031\066\031\066\065\046\031" +
    "\066\031\066\074\064\063\044\074\064\074\064" +
    "\073\062\062\056\073\062\073\062\072\060\060" +
    "\054\072\060\072\060\065\046\071\171\065\157" +
    "\065\161\063\044\064\052\063\157\063\161\062" +
    "\056\061\050\062\056\062\056\060\054\033\040" +
    "\060\054\060\054\034\121\034\123\071\157\071" +
    "\161\064\052\047\063\015\063\014\063\061\050" +
    "\075\001\011\045\027\003\033\117\027\005\027" +
    "\007\027\011\027\013\027\015\011\047\011\051" +
    "\011\053\011\055\011\057\027\017\027\021\026" +
    "\003\040\133\026\005\026\007\026\011\026\013" +
    "\026\015\040\047\040\051\040\053\040\055\040" +
    "\057\026\017\026\021\025\003\037\131\025\005" +
    "\025\007\025\011\025\013\025\015\037\047\037" +
    "\051\037\053\037\055\037\057\025\017\025\021" +
    "\024\003\036\127\024\005\024\007\024\011\024" +
    "\013\024\015\036\047\036\051\036\053\036\055" +
    "\036\057\024\017\024\021\023\003\013\061\023" +
    "\005\023\007\023\011\023\013\023\015\013\047" +
    "\013\051\013\053\013\055\013\057\023\017\023" +
    "\021\020\003\075\001\020\005\020\007\020\011" +
    "\020\013\020\015\070\137\075\001\075\001\070" +
    "\063\070\141\020\017\020\021\017\003\075\001" +
    "\017\005\017\007\017\011\017\013\017\015\067" +
    "\137\075\001\075\001\067\063\067\141\017\017" +
    "\017\021\016\003\075\001\016\005\016\007\016" +
    "\011\016\013\016\015\066\137\075\001\075\001" +
    "\066\063\066\141\016\017\016\021\010\003\075" +
    "\001\010\005\010\007\010\011\010\013\010\015" +
    "\075\001\075\001\075\001\075\001\075\001\010" +
    "\017\010\021\001\003\075\001\001\005\001\007" +
    "\001\011\001\013\001\015\075\001\075\001\075" +
    "\001\075\001\075\001\001\017\001\021\000\003" +
    "\075\001\000\005\000\007\000\011\000\013\000" +
    "\015\055\022\075\001\055\022\075\001\075\001" +
    "\000\017\000\021\075\001\055\022\055\022\055" +
    "\022\055\022\055\022\054\020\075\001\054\020" +
    "\075\001\075\001\053\016\075\001\053\016\054" +
    "\020\054\020\054\020\054\020\054\020\053\016" +
    "\053\016\053\016\053\016\053\016\052\034\075" +
    "\001\052\034\075\001\075\001\046\032\075\001" +
    "\046\032\052\034\052\034\052\034\052\034\052" +
    "\034\046\032\046\032\046\032\046\032\046\032" +
    "\045\010\075\001\045\010\075\001\075\001\044" +
    "\006\075\001\044\006\045\047\045\051\045\053" +
    "\045\055\045\057\044\047\044\051\044\053\044" +
    "\006\044\006\043\004\075\001\043\004\075\001" +
    "\075\001\042\014\075\001\042\014\043\047\043" +
    "\051\043\004\043\004\043\004\042\014\042\014" +
    "\042\014\042\014\042\014\041\012\075\001\041" +
    "\012\075\001\075\001\030\026\075\001\030\026" +
    "\041\012\041\012\041\012\041\012\041\012\030" +
    "\026\030\026\030\026\030\026\030\026\021\024" +
    "\075\001\021\024\075\001\075\001\012\030\075" +
    "\001\012\030\021\024\021\024\021\024\021\024" +
    "\021\024\012\030\012\030\012\030\012\030\012" +
    "\030\004\036\051\137\004\036\075\001\051\063" +
    "\051\141\051\151\075\001\004\036\004\036\004" +
    "\036\004\036\004\036\050\137\075\001\075\001" +
    "\050\063\050\141\050\143\075\001\075\001\075" +
    "\001\075\001\075\001\075\001\075\001\075\055" +
    "\053\001\056\033\034\045\012\051\035\033\034" +
    "\025\006\044\042\040\044\012\036\034\032\020" +
    "\005\032\033\034\043\012\042\012\041\012\040" +
    "\012\037\012\036\012\000\066\064\021\012\013" +
    "\012\011\012\062\073\062\072\062\071\057\055" +
    "\053\062\065\062\063"
    });

  /** Return parse table */
  protected com.github.jhoenicke.javacup.runtime.ParseTable parse_table() {
    return CUP$parse_table;
  }

  /** Instance of action encapsulation class. */
  protected CUP$P4LTLParser$action action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$P4LTLParser$action(this);
    }

  /** Invoke a user supplied parse action. */
  public com.github.jhoenicke.javacup.runtime.Symbol do_action(
    int                        act_num,
    java.util.ArrayList        stack)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$do_action(act_num, stack);
  }

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$P4LTLParser$action {
  private final P4LTLParser parser;

  /** Constructor */
  CUP$P4LTLParser$action(P4LTLParser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final com.github.jhoenicke.javacup.runtime.Symbol CUP$do_action(
    int                        CUP$act_num,
    java.util.ArrayList            CUP$stack)
    throws java.lang.Exception
    {
      /* Stack size for peeking into the stack */
      int CUP$size = CUP$stack.size();

      /* select the action based on the action number */
      switch (CUP$act_num)
        {
          // $START ::= texpr EOF 
          case 0:
            {
              Object RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol CUP$rhs$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int CUP$rhsleft = CUP$rhs$.left;
              int CUP$rhsright = CUP$rhs$.right;
              AstNode CUP$rhs = (AstNode) CUP$rhs$.value;
RESULT = CUP$rhs;
/* ACCEPT */
parser.done_parsing();
              return parser.getSymbolFactory().newSymbol("$START", 0, CUP$rhs$, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= texpr AND texpr 
          case 1:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.and, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= texpr OR texpr 
          case 2:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.or, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= texpr IMPLIES texpr 
          case 3:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.implies, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= texpr UNTIL texpr 
          case 4:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.until, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= texpr RELEASE texpr 
          case 5:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.release, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= ALWAYS LPAR texpr RPAR 
          case 6:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = new UnaryTemporalOperator(UnaryTemporalType.always, t); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= EVENTUALLY LPAR texpr RPAR 
          case 7:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = new UnaryTemporalOperator(UnaryTemporalType.eventually, t); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= NEXT LPAR texpr RPAR 
          case 8:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = new UnaryTemporalOperator(UnaryTemporalType.next, t); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= NEG texpr 
          case 9:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = new UnaryTemporalOperator(UnaryTemporalType.neg, t); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2)), t$, RESULT);
            }

          // texpr ::= LPAR texpr RPAR 
          case 10:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = t; 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= predicate 
          case 11:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol p$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int pleft = p$.left;
              int pright = p$.right;
              AstNode p = (AstNode) p$.value;
 RESULT = p; 
              return parser.getSymbolFactory().newSymbol("texpr", 1, p$, p$, RESULT);
            }

          // predicate ::= MATCH LPAR match_args RPAR 
          case 12:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol margs$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int margsleft = margs$.left;
              int margsright = margs$.right;
              AstNode margs = (AstNode) margs$.value;
 RESULT = new Predicate(PredicateType.match, margs); 
              return parser.getSymbolFactory().newSymbol("predicate", 2, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // predicate ::= MODIFY LPAR match_args RPAR 
          case 13:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol margs$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int margsleft = margs$.left;
              int margsright = margs$.right;
              AstNode margs = (AstNode) margs$.value;
 RESULT = new Predicate(PredicateType.modify, margs); 
              return parser.getSymbolFactory().newSymbol("predicate", 2, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // predicate ::= DROP 
          case 14:
            {
              AstNode RESULT;
 RESULT = new Predicate(PredicateType.drop); 
              com.github.jhoenicke.javacup.runtime.Symbol CUP$sym = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              return parser.getSymbolFactory().newSymbol("predicate", 2, CUP$sym, CUP$sym, RESULT);
            }

          // match_args ::= header_eq 
          case 15:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol he$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int heleft = he$.left;
              int heright = he$.right;
              AstNode he = (AstNode) he$.value;
 RESULT = new Arguments(he); 
              return parser.getSymbolFactory().newSymbol("match_args", 3, he$, he$, RESULT);
            }

          // match_args ::= header_eq COMMA match_args 
          case 16:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol m$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int mleft = m$.left;
              int mright = m$.right;
              AstNode m = (AstNode) m$.value;
              com.github.jhoenicke.javacup.runtime.Symbol he$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int heleft = he$.left;
              int heright = he$.right;
              AstNode he = (AstNode) he$.value;
 RESULT = new Arguments(he, m); 
              return parser.getSymbolFactory().newSymbol("match_args", 3, he$, m$, RESULT);
            }

          // header_eq ::= name EQ expr 
          case 17:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol e$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int eleft = e$.left;
              int eright = e$.right;
              AstNode e = (AstNode) e$.value;
              com.github.jhoenicke.javacup.runtime.Symbol n$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int nleft = n$.left;
              int nright = n$.right;
              AstNode n = (AstNode) n$.value;
 RESULT = new ExtendedComparativeOperator(ExtendedComparativeType.eq, n, e); 
              return parser.getSymbolFactory().newSymbol("header_eq", 4, n$, e$, RESULT);
            }

          // header_eq ::= name NEQ expr 
          case 18:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol e$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int eleft = e$.left;
              int eright = e$.right;
              AstNode e = (AstNode) e$.value;
              com.github.jhoenicke.javacup.runtime.Symbol n$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int nleft = n$.left;
              int nright = n$.right;
              AstNode n = (AstNode) n$.value;
 RESULT = new ExtendedComparativeOperator(ExtendedComparativeType.neq, n, e); 
              return parser.getSymbolFactory().newSymbol("header_eq", 4, n$, e$, RESULT);
            }

          // header_eq ::= name EQ IPMASK 
          case 19:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol ip$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int ipleft = ip$.left;
              int ipright = ip$.right;
              String ip = (String) ip$.value;
              com.github.jhoenicke.javacup.runtime.Symbol n$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int nleft = n$.left;
              int nright = n$.right;
              AstNode n = (AstNode) n$.value;
 RESULT = new ExtendedComparativeOperator(ExtendedComparativeType.eq, n, new IPMask(ip)); 
              return parser.getSymbolFactory().newSymbol("header_eq", 4, n$, ip$, RESULT);
            }

          // header_eq ::= name NEQ IPMASK 
          case 20:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol ip$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int ipleft = ip$.left;
              int ipright = ip$.right;
              String ip = (String) ip$.value;
              com.github.jhoenicke.javacup.runtime.Symbol n$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int nleft = n$.left;
              int nright = n$.right;
              AstNode n = (AstNode) n$.value;
 RESULT = new ExtendedComparativeOperator(ExtendedComparativeType.neq, n, new IPMask(ip)); 
              return parser.getSymbolFactory().newSymbol("header_eq", 4, n$, ip$, RESULT);
            }

          // expr ::= BVINT 
          case 21:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol bvi$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int bvileft = bvi$.left;
              int bviright = bvi$.right;
              String bvi = (String) bvi$.value;
 RESULT = new BitVec(bvi); 
              return parser.getSymbolFactory().newSymbol("expr", 6, bvi$, bvi$, RESULT);
            }

          // expr ::= name 
          case 22:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol n$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int nleft = n$.left;
              int nright = n$.right;
              AstNode n = (AstNode) n$.value;
 RESULT = n; 
              return parser.getSymbolFactory().newSymbol("expr", 6, n$, n$, RESULT);
            }

          // expr ::= expr PLUS expr 
          case 23:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol e2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int e2left = e2$.left;
              int e2right = e2$.right;
              AstNode e2 = (AstNode) e2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol e1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int e1left = e1$.left;
              int e1right = e1$.right;
              AstNode e1 = (AstNode) e1$.value;
 RESULT = new BinaryBitVecOperator(BinaryType.plus, e1, e2); 
              return parser.getSymbolFactory().newSymbol("expr", 6, e1$, e2$, RESULT);
            }

          // expr ::= expr MINUS expr 
          case 24:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol e2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int e2left = e2$.left;
              int e2right = e2$.right;
              AstNode e2 = (AstNode) e2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol e1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int e1left = e1$.left;
              int e1right = e1$.right;
              AstNode e1 = (AstNode) e1$.value;
 RESULT = new BinaryBitVecOperator(BinaryType.minus, e1, e2); 
              return parser.getSymbolFactory().newSymbol("expr", 6, e1$, e2$, RESULT);
            }

          // expr ::= OLD LPAR expr RPAR 
          case 25:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol e$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int eleft = e$.left;
              int eright = e$.right;
              AstNode e = (AstNode) e$.value;
 RESULT = new UnaryBitVecOperator(UnaryTemporalType.old, e); 
              return parser.getSymbolFactory().newSymbol("expr", 6, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // name ::= NAME 
          case 26:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol m$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int mleft = m$.left;
              int mright = m$.right;
              String m = (String) m$.value;
 RESULT = new Name(m); 
              return parser.getSymbolFactory().newSymbol("name", 5, m$, m$, RESULT);
            }

          /* . . . . . .*/
          default:
            throw new InternalError(
               "Invalid action number found in internal parse table");

        }
    }
}

