
//----------------------------------------------------
// The following code was generated by jh-javacup-1.2 20210807
// Fri Jul 15 21:10:46 CST 2022
//----------------------------------------------------

package edu.tsinghua.ss.thufv.specLang.parse;

import com.github.jhoenicke.javacup.runtime.*;
import de.uni_freiburg.informatik.ultimate.ltl2aut.ast.*;
import ast.*;
import java.util.ArrayList;
import java.math.BigInteger;

/** jh-javacup-1.2 20210807 generated parser.
  * @version Fri Jul 15 21:10:46 CST 2022
  */
public class P4LTLParser extends com.github.jhoenicke.javacup.runtime.LRParser {

  /** Default constructor. */
  public P4LTLParser() {super();}

  /** Constructor which sets the default scanner. */
  public P4LTLParser(com.github.jhoenicke.javacup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public P4LTLParser(com.github.jhoenicke.javacup.runtime.Scanner s, com.github.jhoenicke.javacup.runtime.SymbolFactory sf) {super(s,sf);}
  /** The static parse table */
  static com.github.jhoenicke.javacup.runtime.ParseTable CUP$parse_table =
    new com.github.jhoenicke.javacup.runtime.ParseTable(new String[] {
    "\100\000\002\001\003\001\003\001\003\001\003" +
    "\001\003\001\004\001\004\001\004\001\002\001" +
    "\003\001\001\002\004\002\004\002\001\002\004" +
    "\002\004\002\004\003\001\003\003\004\001\004" +
    "\003\005\003\005\003\005\003\005\003\007\001" +
    "\007\001\007\003\007\003\007\004\006\001\114" +
    "\u0218\u01ea\354\346\u0320\312\304\276\u01bc\270\234" +
    "\226\114\u0306\u034a\u0162\u0158\u018e\u0160\u0132\u02fc\u016a" +
    "\u0148\u0146\220\u0104\326\250\172\114\u02e2\114\u014c" +
    "\u014e\154\u0144\u0340\u032a\u016e\u0124\u0118\u0132\u0112\u02d8" +
    "\u02be\u02b4\u029a\u0290\u0276\u0144\u0340\u0126\u026c\u0252\u0248" +
    "\u0228\u01fa\u01cc\u0134\u019e\366\220\u0104\u0120\362\326" +
    "\154\304\360\u035a\u034a\u0346\u011e\250\226\172\u0396" +
    "\000\000\000\000\000\000\000\000\000\000\000" +
    "\000\000\000\000\000\000\000\000\000\000\000" +
    "\000\000\000\000\000\000\000\000\000\000\000" +
    "\000\000\000\000\000\000\000\000\000\000\000" +
    "\000\000\000\000\000\000\000\000\000\000\000" +
    "\000\000\000\000\000\000\000\000\000\000\000" +
    "\000\000\000\000\000\000\000\000\000\000\114" +
    "\001\014\061\035\003\037\100\035\005\035\007" +
    "\035\011\035\013\035\015\014\063\014\065\014" +
    "\067\014\071\014\073\035\017\035\021\037\100" +
    "\037\100\037\100\102\064\037\100\037\100\035" +
    "\023\035\025\035\027\034\003\113\076\034\005" +
    "\034\007\034\011\034\013\034\015\042\145\042" +
    "\147\102\064\030\002\075\213\034\017\034\021" +
    "\013\057\112\074\113\076\012\055\113\076\113" +
    "\076\034\023\034\025\034\027\033\003\111\072" +
    "\033\005\033\007\033\011\033\013\033\015\112" +
    "\074\011\053\112\074\112\074\007\047\033\017" +
    "\033\021\006\045\103\060\111\072\005\043\111" +
    "\072\111\072\033\023\033\025\033\027\032\003" +
    "\101\056\032\005\032\007\032\011\032\013\032" +
    "\015\103\060\003\041\103\215\103\217\002\037" +
    "\032\017\032\021\104\054\100\070\101\056\074" +
    "\050\101\215\101\217\032\023\032\025\032\027" +
    "\031\003\076\066\031\005\031\007\031\011\031" +
    "\013\031\015\100\070\052\167\100\070\100\070" +
    "\050\163\031\017\031\021\110\227\077\062\076" +
    "\066\047\161\076\066\076\066\031\023\031\025" +
    "\031\027\023\003\051\052\023\005\023\007\023" +
    "\011\023\013\023\015\077\062\110\215\110\217" +
    "\043\151\063\173\023\017\023\021\040\141\041" +
    "\046\051\165\063\077\063\175\063\205\023\023" +
    "\023\025\023\027\022\003\072\077\022\005\022" +
    "\007\022\011\022\013\022\015\041\143\046\157" +
    "\061\077\027\077\026\077\022\017\022\021\046" +
    "\063\046\065\046\067\046\071\046\073\020\077" +
    "\022\023\022\025\022\027\021\003\017\077\021" +
    "\005\021\007\021\011\021\013\021\015\073\044" +
    "\025\117\073\044\114\001\114\001\021\017\021" +
    "\021\114\001\073\044\073\044\073\044\073\044" +
    "\073\044\021\023\021\025\021\027\010\003\114" +
    "\001\010\005\010\007\010\011\010\013\010\015" +
    "\071\042\114\001\071\042\114\001\114\001\010" +
    "\017\010\021\114\001\071\042\071\042\071\042" +
    "\071\042\071\042\010\023\010\025\010\027\001" +
    "\003\114\001\001\005\001\007\001\011\001\013" +
    "\001\015\070\040\114\001\070\040\114\001\114" +
    "\001\001\017\001\021\114\001\070\040\070\040" +
    "\070\040\070\040\070\040\001\023\001\025\001" +
    "\027\000\003\114\001\000\005\000\007\000\011" +
    "\000\013\000\015\067\022\114\001\067\022\114" +
    "\001\114\001\000\017\000\021\114\001\067\022" +
    "\067\022\067\022\067\022\067\022\000\023\000" +
    "\025\000\027\066\020\114\001\066\020\114\001" +
    "\114\001\065\016\114\001\065\016\066\020\066" +
    "\020\066\020\066\020\066\020\065\016\065\016" +
    "\065\016\065\016\065\016\064\034\114\001\064" +
    "\034\114\001\114\001\060\032\114\001\060\032" +
    "\064\034\064\034\064\034\064\034\064\034\060" +
    "\032\060\032\060\032\060\032\060\032\057\010" +
    "\114\001\057\010\114\001\114\001\056\006\114" +
    "\001\056\006\057\063\057\065\057\067\057\071" +
    "\057\073\056\063\056\065\056\067\056\006\056" +
    "\006\055\004\114\001\055\004\114\001\114\001" +
    "\054\014\114\001\054\014\055\063\055\065\055" +
    "\004\055\004\055\004\054\014\054\014\054\014" +
    "\054\014\054\014\053\012\114\001\053\012\114" +
    "\001\114\001\036\026\114\001\036\026\053\012" +
    "\053\012\053\012\053\012\053\012\036\026\036" +
    "\026\036\026\036\026\036\026\024\024\114\001" +
    "\024\024\114\001\114\001\015\030\114\001\015" +
    "\030\024\024\024\024\024\024\024\024\024\024" +
    "\015\030\015\030\015\030\015\030\015\030\004" +
    "\036\114\001\004\036\114\001\114\001\114\001" +
    "\114\001\045\155\004\036\004\036\004\036\004" +
    "\036\004\036\045\063\045\065\045\067\045\071" +
    "\045\073\044\153\114\001\114\001\114\001\114" +
    "\001\016\075\044\063\044\065\044\067\044\071" +
    "\044\073\016\063\016\065\016\067\016\071\016" +
    "\073\062\173\114\001\114\001\107\173\114\001" +
    "\106\173\062\077\062\175\062\177\107\077\107" +
    "\175\106\077\106\175\105\173\114\001\114\001" +
    "\114\001\114\001\114\001\105\077\105\175\114" +
    "\001\114\001\114\001\112\072\067\001\074\001" +
    "\041\042\043\065\041\042\040\001\041\042\010" +
    "\004\063\056\054\057\015\036\033\001\052\050" +
    "\046\044\023\104\052\051\051\050\001\051\056" +
    "\015\055\015\054\015\053\015\046\015\045\015" +
    "\000\102\075\044\015\024\015\016\015\032\014" +
    "\015\100\112\100\111\100\110\100\103\073\071" +
    "\067\100\101"
    });

  /** Return parse table */
  protected com.github.jhoenicke.javacup.runtime.ParseTable parse_table() {
    return CUP$parse_table;
  }

  /** Instance of action encapsulation class. */
  protected CUP$P4LTLParser$action action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$P4LTLParser$action(this);
    }

  /** Invoke a user supplied parse action. */
  public com.github.jhoenicke.javacup.runtime.Symbol do_action(
    int                        act_num,
    java.util.ArrayList        stack)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$do_action(act_num, stack);
  }

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$P4LTLParser$action {
  private final P4LTLParser parser;

  /** Constructor */
  CUP$P4LTLParser$action(P4LTLParser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final com.github.jhoenicke.javacup.runtime.Symbol CUP$do_action(
    int                        CUP$act_num,
    java.util.ArrayList            CUP$stack)
    throws java.lang.Exception
    {
      /* Stack size for peeking into the stack */
      int CUP$size = CUP$stack.size();

      /* select the action based on the action number */
      switch (CUP$act_num)
        {
          // $START ::= texpr EOF 
          case 0:
            {
              Object RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol CUP$rhs$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int CUP$rhsleft = CUP$rhs$.left;
              int CUP$rhsright = CUP$rhs$.right;
              AstNode CUP$rhs = (AstNode) CUP$rhs$.value;
RESULT = CUP$rhs;
/* ACCEPT */
parser.done_parsing();
              return parser.getSymbolFactory().newSymbol("$START", 0, CUP$rhs$, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= texpr AND texpr 
          case 1:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.and, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= texpr OR texpr 
          case 2:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.or, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= texpr IMPLIES texpr 
          case 3:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.implies, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= texpr UNTIL texpr 
          case 4:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.until, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= texpr RELEASE texpr 
          case 5:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.release, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= ALWAYS LPAR texpr RPAR 
          case 6:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = new UnaryTemporalOperator(UnaryTemporalType.always, t); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= EVENTUALLY LPAR texpr RPAR 
          case 7:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = new UnaryTemporalOperator(UnaryTemporalType.eventually, t); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= NEXT LPAR texpr RPAR 
          case 8:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = new UnaryTemporalOperator(UnaryTemporalType.next, t); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= NEG texpr 
          case 9:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = new UnaryTemporalOperator(UnaryTemporalType.neg, t); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2)), t$, RESULT);
            }

          // texpr ::= LPAR texpr RPAR 
          case 10:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = t; 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= predicate 
          case 11:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol p$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int pleft = p$.left;
              int pright = p$.right;
              AstNode p = (AstNode) p$.value;
 RESULT = p; 
              return parser.getSymbolFactory().newSymbol("texpr", 1, p$, p$, RESULT);
            }

          // predicate ::= MATCH LPAR match_args RPAR 
          case 12:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol margs$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int margsleft = margs$.left;
              int margsright = margs$.right;
              AstNode margs = (AstNode) margs$.value;
 RESULT = new Predicate(PredicateType.match, margs); 
              return parser.getSymbolFactory().newSymbol("predicate", 2, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // predicate ::= MODIFY LPAR match_args RPAR 
          case 13:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol margs$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int margsleft = margs$.left;
              int margsright = margs$.right;
              AstNode margs = (AstNode) margs$.value;
 RESULT = new Predicate(PredicateType.modify, margs); 
              return parser.getSymbolFactory().newSymbol("predicate", 2, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // predicate ::= DROP 
          case 14:
            {
              AstNode RESULT;
 RESULT = new Predicate(PredicateType.drop); 
              com.github.jhoenicke.javacup.runtime.Symbol CUP$sym = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              return parser.getSymbolFactory().newSymbol("predicate", 2, CUP$sym, CUP$sym, RESULT);
            }

          // predicate ::= FWD LPAR INT RPAR 
          case 15:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol i$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int ileft = i$.left;
              int iright = i$.right;
              BigInteger i = (BigInteger) i$.value;
 RESULT = new Predicate(PredicateType.fwd, i); 
              return parser.getSymbolFactory().newSymbol("predicate", 2, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // predicate ::= VALID_AFTER LPAR valid_args RPAR 
          case 16:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol v$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int vleft = v$.left;
              int vright = v$.right;
              AstNode v = (AstNode) v$.value;
 RESULT = new Predicate(PredicateType.valid_after, v); 
              return parser.getSymbolFactory().newSymbol("predicate", 2, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // predicate ::= VALID_BEFORE LPAR valid_args RPAR 
          case 17:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol v$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int vleft = v$.left;
              int vright = v$.right;
              AstNode v = (AstNode) v$.value;
 RESULT = new Predicate(PredicateType.valid_before, v); 
              return parser.getSymbolFactory().newSymbol("predicate", 2, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // match_args ::= header_eq 
          case 18:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol he$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int heleft = he$.left;
              int heright = he$.right;
              AstNode he = (AstNode) he$.value;
 RESULT = new Arguments(he); 
              return parser.getSymbolFactory().newSymbol("match_args", 3, he$, he$, RESULT);
            }

          // match_args ::= header_eq COMMA match_args 
          case 19:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol m$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int mleft = m$.left;
              int mright = m$.right;
              AstNode m = (AstNode) m$.value;
              com.github.jhoenicke.javacup.runtime.Symbol he$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int heleft = he$.left;
              int heright = he$.right;
              AstNode he = (AstNode) he$.value;
 RESULT = new Arguments(he, m); 
              return parser.getSymbolFactory().newSymbol("match_args", 3, he$, m$, RESULT);
            }

          // valid_args ::= name 
          case 20:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol n$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int nleft = n$.left;
              int nright = n$.right;
              AstNode n = (AstNode) n$.value;
 RESULT = new Arguments(n); 
              return parser.getSymbolFactory().newSymbol("valid_args", 4, n$, n$, RESULT);
            }

          // valid_args ::= name COMMA valid_args 
          case 21:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol v$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int vleft = v$.left;
              int vright = v$.right;
              AstNode v = (AstNode) v$.value;
              com.github.jhoenicke.javacup.runtime.Symbol n$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int nleft = n$.left;
              int nright = n$.right;
              AstNode n = (AstNode) n$.value;
 RESULT = new Arguments(n, v); 
              return parser.getSymbolFactory().newSymbol("valid_args", 4, n$, v$, RESULT);
            }

          // header_eq ::= name EQ expr 
          case 22:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol e$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int eleft = e$.left;
              int eright = e$.right;
              AstNode e = (AstNode) e$.value;
              com.github.jhoenicke.javacup.runtime.Symbol n$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int nleft = n$.left;
              int nright = n$.right;
              AstNode n = (AstNode) n$.value;
 RESULT = new ExtendedComparativeOperator(ExtendedComparativeType.eq, n, e); 
              return parser.getSymbolFactory().newSymbol("header_eq", 5, n$, e$, RESULT);
            }

          // header_eq ::= name NEQ expr 
          case 23:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol e$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int eleft = e$.left;
              int eright = e$.right;
              AstNode e = (AstNode) e$.value;
              com.github.jhoenicke.javacup.runtime.Symbol n$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int nleft = n$.left;
              int nright = n$.right;
              AstNode n = (AstNode) n$.value;
 RESULT = new ExtendedComparativeOperator(ExtendedComparativeType.neq, n, e); 
              return parser.getSymbolFactory().newSymbol("header_eq", 5, n$, e$, RESULT);
            }

          // header_eq ::= name EQ IPMASK 
          case 24:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol ip$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int ipleft = ip$.left;
              int ipright = ip$.right;
              String ip = (String) ip$.value;
              com.github.jhoenicke.javacup.runtime.Symbol n$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int nleft = n$.left;
              int nright = n$.right;
              AstNode n = (AstNode) n$.value;
 RESULT = new ExtendedComparativeOperator(ExtendedComparativeType.eq, n, new IPMask(ip)); 
              return parser.getSymbolFactory().newSymbol("header_eq", 5, n$, ip$, RESULT);
            }

          // header_eq ::= name NEQ IPMASK 
          case 25:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol ip$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int ipleft = ip$.left;
              int ipright = ip$.right;
              String ip = (String) ip$.value;
              com.github.jhoenicke.javacup.runtime.Symbol n$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int nleft = n$.left;
              int nright = n$.right;
              AstNode n = (AstNode) n$.value;
 RESULT = new ExtendedComparativeOperator(ExtendedComparativeType.neq, n, new IPMask(ip)); 
              return parser.getSymbolFactory().newSymbol("header_eq", 5, n$, ip$, RESULT);
            }

          // expr ::= BVINT 
          case 26:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol bvi$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int bvileft = bvi$.left;
              int bviright = bvi$.right;
              String bvi = (String) bvi$.value;
 RESULT = new BitVec(bvi); 
              return parser.getSymbolFactory().newSymbol("expr", 7, bvi$, bvi$, RESULT);
            }

          // expr ::= name 
          case 27:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol n$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int nleft = n$.left;
              int nright = n$.right;
              AstNode n = (AstNode) n$.value;
 RESULT = n; 
              return parser.getSymbolFactory().newSymbol("expr", 7, n$, n$, RESULT);
            }

          // expr ::= expr PLUS expr 
          case 28:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol e2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int e2left = e2$.left;
              int e2right = e2$.right;
              AstNode e2 = (AstNode) e2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol e1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int e1left = e1$.left;
              int e1right = e1$.right;
              AstNode e1 = (AstNode) e1$.value;
 RESULT = new BinaryBitVecOperator(BinaryType.plus, e1, e2); 
              return parser.getSymbolFactory().newSymbol("expr", 7, e1$, e2$, RESULT);
            }

          // expr ::= expr MINUS expr 
          case 29:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol e2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int e2left = e2$.left;
              int e2right = e2$.right;
              AstNode e2 = (AstNode) e2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol e1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int e1left = e1$.left;
              int e1right = e1$.right;
              AstNode e1 = (AstNode) e1$.value;
 RESULT = new BinaryBitVecOperator(BinaryType.minus, e1, e2); 
              return parser.getSymbolFactory().newSymbol("expr", 7, e1$, e2$, RESULT);
            }

          // expr ::= OLD LPAR expr RPAR 
          case 30:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol e$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int eleft = e$.left;
              int eright = e$.right;
              AstNode e = (AstNode) e$.value;
 RESULT = new UnaryBitVecOperator(UnaryTemporalType.old, e); 
              return parser.getSymbolFactory().newSymbol("expr", 7, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // name ::= NAME 
          case 31:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol m$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int mleft = m$.left;
              int mright = m$.right;
              String m = (String) m$.value;
 RESULT = new Name(m); 
              return parser.getSymbolFactory().newSymbol("name", 6, m$, m$, RESULT);
            }

          /* . . . . . .*/
          default:
            throw new InternalError(
               "Invalid action number found in internal parse table");

        }
    }
}

