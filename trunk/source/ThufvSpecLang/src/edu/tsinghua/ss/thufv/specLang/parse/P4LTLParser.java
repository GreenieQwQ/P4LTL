
//----------------------------------------------------
// The following code was generated by jh-javacup-1.2 20210807
// Sun Jul 10 13:19:39 CST 2022
//----------------------------------------------------

package edu.tsinghua.ss.thufv.specLang.parse;

import com.github.jhoenicke.javacup.runtime.*;
import de.uni_freiburg.informatik.ultimate.ltl2aut.ast.*;
import ast.*;
import java.util.ArrayList;
import java.math.BigInteger;

/** jh-javacup-1.2 20210807 generated parser.
  * @version Sun Jul 10 13:19:39 CST 2022
  */
public class P4LTLParser extends com.github.jhoenicke.javacup.runtime.LRParser {

  /** Default constructor. */
  public P4LTLParser() {super();}

  /** Constructor which sets the default scanner. */
  public P4LTLParser(com.github.jhoenicke.javacup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public P4LTLParser(com.github.jhoenicke.javacup.runtime.Scanner s, com.github.jhoenicke.javacup.runtime.SymbolFactory sf) {super(s,sf);}
  /** The static parse table */
  static com.github.jhoenicke.javacup.runtime.ParseTable CUP$parse_table =
    new com.github.jhoenicke.javacup.runtime.ParseTable(new String[] {
    "\054\000\002\001\003\001\003\001\003\001\003" +
    "\001\003\001\004\001\004\001\004\001\002\001" +
    "\003\001\001\002\004\002\004\002\001\003\001" +
    "\003\003\004\003\004\003\004\003\004\003\005" +
    "\001\063\u015d\u0141\107\103\u025f\101\077\063\u0125" +
    "\u0269\u0245\265\365\351\u0109\355\321\u023b\063\265" +
    "\231\175\141\105\u0221\307\355\073\303\345\231" +
    "\175\141\u0217\u01fd\u01f3\u01d9\u01cf\u01b5\341\333\327" +
    "\u01ab\u0191\u0187\u016d\321\071\067\065\063\u0299\000" +
    "\000\000\000\000\000\000\000\000\000\000\000" +
    "\000\000\000\000\000\000\000\000\000\000\000" +
    "\000\000\000\000\000\000\000\000\000\000\000" +
    "\000\000\000\000\000\000\000\000\000\000\000" +
    "\000\000\000\000\000\000\063\001\022\002\007" +
    "\041\062\052\061\046\060\050\057\044\033\040" +
    "\006\037\005\035\003\033\027\003\002\031\027" +
    "\005\027\007\027\011\027\013\027\015\062\052" +
    "\061\046\060\050\057\044\033\117\027\017\027" +
    "\021\026\003\040\133\026\005\026\007\026\011" +
    "\026\013\026\015\040\047\040\051\040\053\040" +
    "\055\040\057\026\017\026\021\025\003\037\131" +
    "\025\005\025\007\025\011\025\013\025\015\037" +
    "\047\037\051\037\053\037\055\037\057\025\017" +
    "\025\021\024\003\036\127\024\005\024\007\024" +
    "\011\024\013\024\015\036\047\036\051\036\053" +
    "\036\055\036\057\024\017\024\021\023\003\013" +
    "\061\023\005\023\007\023\011\023\013\023\015" +
    "\013\047\013\051\013\053\013\055\013\057\023" +
    "\017\023\021\020\003\056\042\020\005\020\007" +
    "\020\011\020\013\020\015\034\121\034\123\031" +
    "\054\031\054\035\125\020\017\020\021\017\003" +
    "\032\115\017\005\017\007\017\011\017\013\017" +
    "\015\051\143\051\145\050\137\050\141\047\063" +
    "\017\017\017\021\016\003\015\063\016\005\016" +
    "\007\016\011\016\013\016\015\014\063\063\001" +
    "\063\001\063\001\063\001\016\017\016\021\010" +
    "\003\063\001\010\005\010\007\010\011\010\013" +
    "\010\015\063\001\063\001\063\001\063\001\063" +
    "\001\010\017\010\021\001\003\063\001\001\005" +
    "\001\007\001\011\001\013\001\015\063\001\063" +
    "\001\063\001\063\001\063\001\001\017\001\021" +
    "\000\003\063\001\000\005\000\007\000\011\000" +
    "\013\000\015\055\022\063\001\055\022\063\001" +
    "\063\001\000\017\000\021\063\001\055\022\055" +
    "\022\055\022\055\022\055\022\054\020\063\001" +
    "\054\020\063\001\063\001\053\016\063\001\053" +
    "\016\054\020\054\020\054\020\054\020\054\020" +
    "\053\016\053\016\053\016\053\016\053\016\052" +
    "\034\063\001\052\034\063\001\063\001\046\032" +
    "\063\001\046\032\052\034\052\034\052\034\052" +
    "\034\052\034\046\032\046\032\046\032\046\032" +
    "\046\032\045\010\063\001\045\010\063\001\063" +
    "\001\044\006\063\001\044\006\045\047\045\051" +
    "\045\053\045\055\045\057\044\047\044\051\044" +
    "\053\044\006\044\006\043\004\063\001\043\004" +
    "\063\001\063\001\042\014\063\001\042\014\043" +
    "\047\043\051\043\004\043\004\043\004\042\014" +
    "\042\014\042\014\042\014\042\014\041\012\063" +
    "\001\041\012\063\001\063\001\030\026\063\001" +
    "\030\026\041\012\041\012\041\012\041\012\041" +
    "\012\030\026\030\026\030\026\030\026\030\026" +
    "\021\024\063\001\021\024\063\001\063\001\012" +
    "\030\063\001\012\030\021\024\021\024\021\024" +
    "\021\024\021\024\012\030\012\030\012\030\012" +
    "\030\012\030\004\036\063\001\004\036\063\001" +
    "\063\001\011\045\063\001\063\001\004\036\004" +
    "\036\004\036\004\036\004\036\011\047\011\051" +
    "\011\053\011\055\011\057\063\001\063\001\063" +
    "\001\063\001\063\001\063\001\063\001\063\001" +
    "\063\001\063\001\056\053\051\001\056\033\034" +
    "\045\012\047\035\033\034\025\006\044\042\040" +
    "\044\012\036\034\032\020\005\032\033\034\043" +
    "\012\042\012\041\012\040\012\037\012\036\012" +
    "\000\021\012\013\012\011\012"
    });

  /** Return parse table */
  protected com.github.jhoenicke.javacup.runtime.ParseTable parse_table() {
    return CUP$parse_table;
  }

  /** Instance of action encapsulation class. */
  protected CUP$P4LTLParser$action action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$P4LTLParser$action(this);
    }

  /** Invoke a user supplied parse action. */
  public com.github.jhoenicke.javacup.runtime.Symbol do_action(
    int                        act_num,
    java.util.ArrayList        stack)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$do_action(act_num, stack);
  }

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$P4LTLParser$action {
  private final P4LTLParser parser;

  /** Constructor */
  CUP$P4LTLParser$action(P4LTLParser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final com.github.jhoenicke.javacup.runtime.Symbol CUP$do_action(
    int                        CUP$act_num,
    java.util.ArrayList            CUP$stack)
    throws java.lang.Exception
    {
      /* Stack size for peeking into the stack */
      int CUP$size = CUP$stack.size();

      /* select the action based on the action number */
      switch (CUP$act_num)
        {
          // $START ::= texpr EOF 
          case 0:
            {
              Object RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol CUP$rhs$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int CUP$rhsleft = CUP$rhs$.left;
              int CUP$rhsright = CUP$rhs$.right;
              AstNode CUP$rhs = (AstNode) CUP$rhs$.value;
RESULT = CUP$rhs;
/* ACCEPT */
parser.done_parsing();
              return parser.getSymbolFactory().newSymbol("$START", 0, CUP$rhs$, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= texpr AND texpr 
          case 1:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.and, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= texpr OR texpr 
          case 2:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.or, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= texpr IMPLIES texpr 
          case 3:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.implies, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= texpr UNTIL texpr 
          case 4:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.until, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= texpr RELEASE texpr 
          case 5:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.release, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= ALWAYS LPAR texpr RPAR 
          case 6:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = new UnaryTemporalOperator(UnaryTemporalType.always, t); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= EVENTUALLY LPAR texpr RPAR 
          case 7:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = new UnaryTemporalOperator(UnaryTemporalType.eventually, t); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= NEXT LPAR texpr RPAR 
          case 8:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = new UnaryTemporalOperator(UnaryTemporalType.next, t); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= NEG texpr 
          case 9:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = new UnaryTemporalOperator(UnaryTemporalType.neg, t); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2)), t$, RESULT);
            }

          // texpr ::= LPAR texpr RPAR 
          case 10:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = t; 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= predicate 
          case 11:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol p$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int pleft = p$.left;
              int pright = p$.right;
              AstNode p = (AstNode) p$.value;
 RESULT = p; 
              return parser.getSymbolFactory().newSymbol("texpr", 1, p$, p$, RESULT);
            }

          // predicate ::= MATCH LPAR match_args RPAR 
          case 12:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol margs$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int margsleft = margs$.left;
              int margsright = margs$.right;
              AstNode margs = (AstNode) margs$.value;
 RESULT = new Predicate(PredicateType.match, margs); 
              return parser.getSymbolFactory().newSymbol("predicate", 2, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // predicate ::= MODIFY LPAR match_args RPAR 
          case 13:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol margs$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int margsleft = margs$.left;
              int margsright = margs$.right;
              AstNode margs = (AstNode) margs$.value;
 RESULT = new Predicate(PredicateType.modify, margs); 
              return parser.getSymbolFactory().newSymbol("predicate", 2, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // predicate ::= DROP 
          case 14:
            {
              AstNode RESULT;
 RESULT = new Predicate(PredicateType.drop); 
              com.github.jhoenicke.javacup.runtime.Symbol CUP$sym = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              return parser.getSymbolFactory().newSymbol("predicate", 2, CUP$sym, CUP$sym, RESULT);
            }

          // match_args ::= header_eq 
          case 15:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol he$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int heleft = he$.left;
              int heright = he$.right;
              AstNode he = (AstNode) he$.value;
 RESULT = new Arguments(he); 
              return parser.getSymbolFactory().newSymbol("match_args", 3, he$, he$, RESULT);
            }

          // match_args ::= header_eq COMMA match_args 
          case 16:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol m$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int mleft = m$.left;
              int mright = m$.right;
              AstNode m = (AstNode) m$.value;
              com.github.jhoenicke.javacup.runtime.Symbol he$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int heleft = he$.left;
              int heright = he$.right;
              AstNode he = (AstNode) he$.value;
 RESULT = new Arguments(he, m); 
              return parser.getSymbolFactory().newSymbol("match_args", 3, he$, m$, RESULT);
            }

          // header_eq ::= name EQ BVINT 
          case 17:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol bvi$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int bvileft = bvi$.left;
              int bviright = bvi$.right;
              String bvi = (String) bvi$.value;
              com.github.jhoenicke.javacup.runtime.Symbol n$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int nleft = n$.left;
              int nright = n$.right;
              AstNode n = (AstNode) n$.value;
 RESULT = new ExtendedComparativeOperator(ExtendedComparativeType.eq, n, new BitVec(bvi)); 
              return parser.getSymbolFactory().newSymbol("header_eq", 4, n$, bvi$, RESULT);
            }

          // header_eq ::= name NEQ BVINT 
          case 18:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol bvi$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int bvileft = bvi$.left;
              int bviright = bvi$.right;
              String bvi = (String) bvi$.value;
              com.github.jhoenicke.javacup.runtime.Symbol n$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int nleft = n$.left;
              int nright = n$.right;
              AstNode n = (AstNode) n$.value;
 RESULT = new ExtendedComparativeOperator(ExtendedComparativeType.neq, n, new BitVec(bvi)); 
              return parser.getSymbolFactory().newSymbol("header_eq", 4, n$, bvi$, RESULT);
            }

          // header_eq ::= name EQ IPMASK 
          case 19:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol ip$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int ipleft = ip$.left;
              int ipright = ip$.right;
              String ip = (String) ip$.value;
              com.github.jhoenicke.javacup.runtime.Symbol n$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int nleft = n$.left;
              int nright = n$.right;
              AstNode n = (AstNode) n$.value;
 RESULT = new ExtendedComparativeOperator(ExtendedComparativeType.eq, n, new IPMask(ip)); 
              return parser.getSymbolFactory().newSymbol("header_eq", 4, n$, ip$, RESULT);
            }

          // header_eq ::= name NEQ IPMASK 
          case 20:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol ip$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int ipleft = ip$.left;
              int ipright = ip$.right;
              String ip = (String) ip$.value;
              com.github.jhoenicke.javacup.runtime.Symbol n$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int nleft = n$.left;
              int nright = n$.right;
              AstNode n = (AstNode) n$.value;
 RESULT = new ExtendedComparativeOperator(ExtendedComparativeType.neq, n, new IPMask(ip)); 
              return parser.getSymbolFactory().newSymbol("header_eq", 4, n$, ip$, RESULT);
            }

          // name ::= NAME 
          case 21:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol m$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int mleft = m$.left;
              int mright = m$.right;
              String m = (String) m$.value;
 RESULT = new Name(m); 
              return parser.getSymbolFactory().newSymbol("name", 5, m$, m$, RESULT);
            }

          /* . . . . . .*/
          default:
            throw new InternalError(
               "Invalid action number found in internal parse table");

        }
    }
}

