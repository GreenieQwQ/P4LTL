
//----------------------------------------------------
// The following code was generated by jh-javacup-1.2 20210807
// Mon Jul 04 11:04:16 CST 2022
//----------------------------------------------------

package edu.tsinghua.ss.thufv.specLang.parse;

import com.github.jhoenicke.javacup.runtime.*;
import de.uni_freiburg.informatik.ultimate.ltl2aut.ast.*;
import ast.*;
import java.util.ArrayList;
import java.math.BigInteger;

/** jh-javacup-1.2 20210807 generated parser.
  * @version Mon Jul 04 11:04:16 CST 2022
  */
public class P4LTLParser extends com.github.jhoenicke.javacup.runtime.LRParser {

  /** Default constructor. */
  public P4LTLParser() {super();}

  /** Constructor which sets the default scanner. */
  public P4LTLParser(com.github.jhoenicke.javacup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public P4LTLParser(com.github.jhoenicke.javacup.runtime.Scanner s, com.github.jhoenicke.javacup.runtime.SymbolFactory sf) {super(s,sf);}
  /** The static parse table */
  static com.github.jhoenicke.javacup.runtime.ParseTable CUP$parse_table =
    new com.github.jhoenicke.javacup.runtime.ParseTable(new String[] {
    "\052\000\002\001\003\001\003\001\003\001\003" +
    "\001\003\001\004\001\004\001\004\001\002\001" +
    "\003\001\001\002\004\002\001\003\001\003\003" +
    "\004\003\004\003\004\003\004\003\005\001\057" +
    "\u0145\u012b\077\u0273\075\073\057\u0111\u027d\u025b\251" +
    "\277\367\335\303\u0243\057\251\217\165\133\101" +
    "\u022b\271\303\067\265\217\165\133\u0213\u01fb\u01e3" +
    "\u01cb\u01b3\u019b\267\313\307\u0183\u016b\u0153\101\065" +
    "\063\061\057\u02a9\000\000\000\000\000\000\000" +
    "\000\000\000\000\000\000\000\000\000\000\000" +
    "\000\000\000\000\000\000\000\000\000\000\000" +
    "\000\000\000\000\000\000\000\000\000\000\000" +
    "\000\000\000\000\000\000\000\057\001\020\002" +
    "\006\035\056\050\055\044\054\046\053\042\031" +
    "\036\005\033\004\031\002\027\025\003\052\040" +
    "\025\005\025\007\025\011\025\013\056\050\055" +
    "\044\054\046\053\042\031\111\025\015\025\017" +
    "\024\003\035\123\024\005\024\007\024\011\024" +
    "\013\035\043\035\045\035\047\035\051\035\053" +
    "\024\015\024\017\023\003\034\121\023\005\023" +
    "\007\023\011\023\013\034\043\034\045\034\047" +
    "\034\051\034\053\023\015\023\017\022\003\033" +
    "\117\022\005\022\007\022\011\022\013\033\043" +
    "\033\045\033\047\033\051\033\053\022\015\022" +
    "\017\021\003\012\055\021\005\021\007\021\011" +
    "\021\013\012\043\012\045\012\047\012\051\012" +
    "\053\021\015\021\017\016\003\030\107\016\005" +
    "\016\007\016\011\016\013\032\113\032\115\027" +
    "\052\027\052\044\057\016\015\016\017\015\003" +
    "\013\057\015\005\015\007\015\011\015\013\046" +
    "\133\046\135\045\127\045\131\057\001\015\015" +
    "\015\017\014\003\057\001\014\005\014\007\014" +
    "\011\014\013\057\001\057\001\057\001\057\001" +
    "\057\001\014\015\014\017\007\003\057\001\007" +
    "\005\007\007\007\011\007\013\057\001\057\001" +
    "\057\001\057\001\057\001\007\015\007\017\001" +
    "\003\057\001\001\005\001\007\001\011\001\013" +
    "\057\001\057\001\057\001\057\001\057\001\001" +
    "\015\001\017\000\003\057\001\000\005\000\007" +
    "\000\011\000\013\051\022\057\001\051\022\057" +
    "\001\057\001\000\015\000\017\051\022\051\022" +
    "\051\022\051\022\051\022\050\020\057\001\050" +
    "\020\057\001\057\001\057\001\057\001\050\020" +
    "\050\020\050\020\050\020\050\020\047\016\057" +
    "\001\047\016\057\001\057\001\057\001\057\001" +
    "\047\016\047\016\047\016\047\016\047\016\043" +
    "\032\057\001\043\032\057\001\057\001\057\001" +
    "\057\001\043\032\043\032\043\032\043\032\043" +
    "\032\042\010\057\001\042\010\057\001\057\001" +
    "\057\001\057\001\042\043\042\045\042\047\042" +
    "\051\042\053\041\006\057\001\041\006\057\001" +
    "\057\001\057\001\057\001\041\043\041\045\041" +
    "\047\041\006\041\006\040\004\057\001\040\004" +
    "\057\001\057\001\057\001\057\001\040\043\040" +
    "\045\040\004\040\004\040\004\037\014\057\001" +
    "\037\014\057\001\057\001\057\001\057\001\037" +
    "\014\037\014\037\014\037\014\037\014\036\012" +
    "\057\001\036\012\057\001\057\001\057\001\057" +
    "\001\036\012\036\012\036\012\036\012\036\012" +
    "\026\026\057\001\026\026\057\001\057\001\057" +
    "\001\057\001\026\026\026\026\026\026\026\026" +
    "\026\026\017\024\057\001\017\024\057\001\057" +
    "\001\057\001\057\001\017\024\017\024\017\024" +
    "\017\024\017\024\011\030\057\001\011\030\057" +
    "\001\057\001\057\001\057\001\011\030\011\030" +
    "\011\030\011\030\011\030\003\034\057\001\003" +
    "\034\057\001\057\001\010\041\057\001\003\034" +
    "\003\034\003\034\003\034\003\034\010\043\010" +
    "\045\010\047\010\051\010\053\057\001\057\001" +
    "\057\001\057\001\057\001\057\001\057\001\057" +
    "\001\057\001\053\050\046\001\052\031\032\001" +
    "\044\030\031\032\005\041\037\035\042\011\033" +
    "\031\027\025\016\041\011\040\011\037\011\036" +
    "\011\035\011\034\011\033\011\000\017\011\012" +
    "\011\010\011"
    });

  /** Return parse table */
  protected com.github.jhoenicke.javacup.runtime.ParseTable parse_table() {
    return CUP$parse_table;
  }

  /** Instance of action encapsulation class. */
  protected CUP$P4LTLParser$action action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$P4LTLParser$action(this);
    }

  /** Invoke a user supplied parse action. */
  public com.github.jhoenicke.javacup.runtime.Symbol do_action(
    int                        act_num,
    java.util.ArrayList        stack)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$do_action(act_num, stack);
  }

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$P4LTLParser$action {
  private final P4LTLParser parser;

  /** Constructor */
  CUP$P4LTLParser$action(P4LTLParser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final com.github.jhoenicke.javacup.runtime.Symbol CUP$do_action(
    int                        CUP$act_num,
    java.util.ArrayList            CUP$stack)
    throws java.lang.Exception
    {
      /* Stack size for peeking into the stack */
      int CUP$size = CUP$stack.size();

      /* select the action based on the action number */
      switch (CUP$act_num)
        {
          // $START ::= texpr EOF 
          case 0:
            {
              Object RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol CUP$rhs$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int CUP$rhsleft = CUP$rhs$.left;
              int CUP$rhsright = CUP$rhs$.right;
              AstNode CUP$rhs = (AstNode) CUP$rhs$.value;
RESULT = CUP$rhs;
/* ACCEPT */
parser.done_parsing();
              return parser.getSymbolFactory().newSymbol("$START", 0, CUP$rhs$, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= texpr AND texpr 
          case 1:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.and, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= texpr OR texpr 
          case 2:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.or, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= texpr IMPLIES texpr 
          case 3:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.implies, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= texpr UNTIL texpr 
          case 4:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.until, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= texpr RELEASE texpr 
          case 5:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t2$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int t2left = t2$.left;
              int t2right = t2$.right;
              AstNode t2 = (AstNode) t2$.value;
              com.github.jhoenicke.javacup.runtime.Symbol t1$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int t1left = t1$.left;
              int t1right = t1$.right;
              AstNode t1 = (AstNode) t1$.value;
 RESULT = new BinaryTemporalOperator(BinaryTemporalType.release, t1, t2); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, t1$, t2$, RESULT);
            }

          // texpr ::= ALWAYS LPAR texpr RPAR 
          case 6:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = new UnaryTemporalOperator(UnaryTemporalType.always, t); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= EVENTUALLY LPAR texpr RPAR 
          case 7:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = new UnaryTemporalOperator(UnaryTemporalType.eventually, t); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= NEXT LPAR texpr RPAR 
          case 8:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = new UnaryTemporalOperator(UnaryTemporalType.next, t); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= NEG texpr 
          case 9:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = new UnaryTemporalOperator(UnaryTemporalType.neg, t); 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2)), t$, RESULT);
            }

          // texpr ::= LPAR texpr RPAR 
          case 10:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol t$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int tleft = t$.left;
              int tright = t$.right;
              AstNode t = (AstNode) t$.value;
 RESULT = t; 
              return parser.getSymbolFactory().newSymbol("texpr", 1, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // texpr ::= predicate 
          case 11:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol p$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int pleft = p$.left;
              int pright = p$.right;
              AstNode p = (AstNode) p$.value;
 RESULT = p; 
              return parser.getSymbolFactory().newSymbol("texpr", 1, p$, p$, RESULT);
            }

          // predicate ::= MATCH LPAR match_args RPAR 
          case 12:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol margs$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 2));
              int margsleft = margs$.left;
              int margsright = margs$.right;
              AstNode margs = (AstNode) margs$.value;
 RESULT = new Predicate(PredicateType.match, margs); 
              return parser.getSymbolFactory().newSymbol("predicate", 2, ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 4)), ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1)), RESULT);
            }

          // predicate ::= DROP 
          case 13:
            {
              AstNode RESULT;
 RESULT = new Predicate(PredicateType.drop); 
              com.github.jhoenicke.javacup.runtime.Symbol CUP$sym = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              return parser.getSymbolFactory().newSymbol("predicate", 2, CUP$sym, CUP$sym, RESULT);
            }

          // match_args ::= header_eq 
          case 14:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol he$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int heleft = he$.left;
              int heright = he$.right;
              AstNode he = (AstNode) he$.value;
 RESULT = new Arguments(he); 
              return parser.getSymbolFactory().newSymbol("match_args", 3, he$, he$, RESULT);
            }

          // match_args ::= header_eq COMMA match_args 
          case 15:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol m$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int mleft = m$.left;
              int mright = m$.right;
              AstNode m = (AstNode) m$.value;
              com.github.jhoenicke.javacup.runtime.Symbol he$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int heleft = he$.left;
              int heright = he$.right;
              AstNode he = (AstNode) he$.value;
 RESULT = new Arguments(he, m); 
              return parser.getSymbolFactory().newSymbol("match_args", 3, he$, m$, RESULT);
            }

          // header_eq ::= name EQ BVINT 
          case 16:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol bvi$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int bvileft = bvi$.left;
              int bviright = bvi$.right;
              String bvi = (String) bvi$.value;
              com.github.jhoenicke.javacup.runtime.Symbol n$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int nleft = n$.left;
              int nright = n$.right;
              AstNode n = (AstNode) n$.value;
 RESULT = new ExtendedComparativeOperator(ExtendedComparativeType.eq, n, new BitVec(bvi)); 
              return parser.getSymbolFactory().newSymbol("header_eq", 4, n$, bvi$, RESULT);
            }

          // header_eq ::= name NEQ BVINT 
          case 17:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol bvi$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int bvileft = bvi$.left;
              int bviright = bvi$.right;
              String bvi = (String) bvi$.value;
              com.github.jhoenicke.javacup.runtime.Symbol n$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int nleft = n$.left;
              int nright = n$.right;
              AstNode n = (AstNode) n$.value;
 RESULT = new ExtendedComparativeOperator(ExtendedComparativeType.neq, n, new BitVec(bvi)); 
              return parser.getSymbolFactory().newSymbol("header_eq", 4, n$, bvi$, RESULT);
            }

          // header_eq ::= name EQ INT 
          case 18:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol i$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int ileft = i$.left;
              int iright = i$.right;
              BigInteger i = (BigInteger) i$.value;
              com.github.jhoenicke.javacup.runtime.Symbol n$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int nleft = n$.left;
              int nright = n$.right;
              AstNode n = (AstNode) n$.value;
 RESULT = new ExtendedComparativeOperator(ExtendedComparativeType.eq, n, new BigIntegerLiteral(i)); 
              return parser.getSymbolFactory().newSymbol("header_eq", 4, n$, i$, RESULT);
            }

          // header_eq ::= name NEQ INT 
          case 19:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol i$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int ileft = i$.left;
              int iright = i$.right;
              BigInteger i = (BigInteger) i$.value;
              com.github.jhoenicke.javacup.runtime.Symbol n$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 3));
              int nleft = n$.left;
              int nright = n$.right;
              AstNode n = (AstNode) n$.value;
 RESULT = new ExtendedComparativeOperator(ExtendedComparativeType.neq, n, new BigIntegerLiteral(i)); 
              return parser.getSymbolFactory().newSymbol("header_eq", 4, n$, i$, RESULT);
            }

          // name ::= NAME 
          case 20:
            {
              AstNode RESULT;
              com.github.jhoenicke.javacup.runtime.Symbol m$ = ((com.github.jhoenicke.javacup.runtime.Symbol) CUP$stack.get(CUP$size - 1));
              int mleft = m$.left;
              int mright = m$.right;
              String m = (String) m$.value;
 RESULT = new Name(m); 
              return parser.getSymbolFactory().newSymbol("name", 5, m$, m$, RESULT);
            }

          /* . . . . . .*/
          default:
            throw new InternalError(
               "Invalid action number found in internal parse table");

        }
    }
}

